<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../polymer/polymer.html">
<script src="../papaparse/papaparse.min.js"></script>
<script src="./lib/utils.js"></script>
<script src="../lz-string/libs/lz-string.min.js"></script>
<script src="../async/lib/async.js"></script>
<!--
An element providing a solution to no problem in particular.

Example:

    <csv-dataframe></csv-dataframe>

@demo
-->
<dom-module id="csv-dataframe">

  <style>
    :host {
      display: block;
      box-sizing: border-box;
    }

  </style>

  <template>
    <div class="content">
      <content></content>
    </div>
  </template>

</dom-module>

<script>

  Polymer({

    is: 'csv-dataframe',

    properties: {
      columns:{
        type: Array
      },
      nrow: Number,
      ncol: Number,
      headers: { 
        type: Boolean,
        reflectToAttribute: true,
        value: true
      },
      store: {
        type: Object
      },
      dataLoaded: {
        type: Boolean,
        value: false,
        notify: true
      },
      view: {
        type: String,
        reflectToAttribute: true,
        oberser: "loadView",
        value: "none"
      },
      data: {
        type: Object,
        notify: true
      },

    },

    // Element Lifecycle
    attached: function() {
      var self, csvStr, cols, csvData, storeName;
      self = this; 
      csvStr = self.querySelector("LINK").import.querySelector('BODY').textContent;
      console.log(csvStr.split('\n').length);
      
      self._extract(csvStr, 
        function(csvArr){
          console.log('Parsed dims:');
          console.log(csvArr[0].length);
          console.log(csvArr.length);
          var load;
          load = self._load.bind(self);
          self._transform(csvArr, load);
        }
      );
    },
    // ETL methods
    _key: function(col){
      var self;
      self = this;
      return (self.name || "csv") + "!" + String(col);
    },
    _compress: function(item){
      return LZString.compress(JSON.stringify(item));
    },
    _decompress: function(item){
      return JSON.parse(LZString.decompress(item));
    },
    _extract: function(csvString, callback){
      var self;
      self = this;
      Papa.parse(csvString, {
        complete: function(res){
          if (res.errors.length > 0){
            console.log("Parsing Error:");
            console.log(res.errors);
            return 
          }
          console.log(res);
          return callback(res.data)
        }
      });
    }, 
    _transform: function(csvArr, callback){
      var self, cols, levels, fvals;
      self = this;
      if (self.headers) {
        cols = csvArr[0];
        vals = csvArr.slice(1);
      } else {
        cols = utils.range(csvArr[0].length).map(
          function (v){
            return "X."+String(v);
          }
        ); 
        vals = csvArr;
      }
      self.columns = cols; 
      self.ncol = cols.length;
      self.nrow = vals.length;
      return callback(
        utils.transpose(vals).reduce(
          function(vob, vs, i){
            vob[cols[i]] = vs;
            return vob
          },
          {}
        )
      )
    },
    _load: function(vals){
      var self, storeName, cols;
      self = this; 
      console.log(self);
      storeName = self.querySelector('LINK').getAttribute('href');

      if("indexedDB" in window) {
        var openRequest;
        openRequest = indexedDB.open(storeName,1);
        openRequest.onupgradeneeded = function(e) {
            console.log("running onupgradeneeded");
            var store;
            store = e.target.result;
            self.columns.forEach(
              function(col){ 
                if(!store.objectStoreNames.contains(col)) {
                  store.createObjectStore(col, {autoIncrement: true });
                  console.log("Creating "+col+" Object Store");
                }


              }
            )
        }
        openRequest.onsuccess = function(e) {
          console.log("Database Opened...");
          var store;
          self.store = store =  e.target.result;
          async.eachSeries(
            self.columns,
            function (col, callback){
              console.log("Loading "+col+"...");
              var objStore, request, colVals;
              objStore = store.transaction([col], 'readwrite').objectStore(col);
              request = objStore.add(vals[col]);
              request.onsuccess = function () { callback() };
              request.onerror = function (e) { callback(e) }
            },
            function (err){
              if (err){ 
                console.log(err); 
              }
              self.fire('data-loaded'); 
              self.dataLoaded = true;
              console.log('Data loaded!');
            }
          )
        }
        openRequest.onerror = function(e) {
            console.log("Error");
            console.dir(e);
        }
      }
    },
    // retrieveSubset: function(rows, cols){
    //   var self;
    //   self = this; 
    //   cols = cols || self.columns;

    //   if (rows && !Array.isArray(rows)){
    //     var colNums, rCols, colParams, scols; 
    //     scols = self.columns;
    //     rCols = Object.keys(rows);
    //     colNums = rCols.map(scols.indexOf);
    //     colParams = rCols.map(utils.getFrom(rows));
    //     utils.range(self.nrows).reduce(
    //       function (subset, rNum){
    //         var r, i;
    //         r = self._retrieveItem(rNum);
    //         i = 0;
    //         for (; i < colNums.length; i++){
    //           if(!(r[i] == colParams[i])){
    //             return subset
    //           }
    //         }
    //         return subset.concat(r);
    //       },
    //       [])
    //   }
    //   rows = rows || range(self.nrow); 
    //   return scols.concat(rows.map(self._retrieveItem).map(utils.keyMap(cols)));
    // }
    // _transform: function(csvArr, callback){
    //   var self, cols, vals, transformed;
    //   self = this;
    //   if (self.headers) {
    //     cols = csvArr[0];
    //     vals = utils.transpose(csvArr.slice(1));
    //   } else {
    //     cols = utils.range(csvArr[0].length).map(
    //       function (v){
    //         return "X."+String(v);
    //       }
    //     ); 
    //     vals = utils.transpose(csvArr);
    //   }
    //   return callback(
    //     vals.reduce(
    //       function(p, c, i){
    //         p[cols[i]] = c;
    //         return p
    //       },
    //       {}
    //     )
    //   )
    // }, 
    // _load: function(csvData){
    //   var self, _key, store;
    //   self = this;
    //   _key = self._key;
    //   store = self.store;
    //   Object.keys(csvData).forEach(
    //     function (col, i) {
    //       console.log("Loading: "+col);
    //       store[self._key(col)] = self._compress(csvData[col])
    //     }
    //   ); 
    //   self.fire('data-loaded'); 
    //   self.dataLoaded = true;
    // },
    // JS API Methods 
    // subsetCols: function(cols){
    //   var self, get, key;
    //   self = this;
    //   _key = self._key
    //   return cols.reduce(
    //     function (ro, col) {
    //       ro[col] = self._decompress(self.store.getItem(_key(col)));
    //       return ro
    //     },
    //     {}
    //   )
    // },
    // subsetRows: function(rexp, csvData){
    //   var self, rrange, mapFn;
    //   self = this;
    //   csvData = csvData || self.subsetCols(self.columns);
    //   rrange = utils.range(self.nrow);
    //   if(Array.isArray(rexp)){
    //     var rmin, rmax;
    //     rmin = rexp[0];
    //     rmax = rexp[1];
    //     mapFn = utils.booleanMap(
    //       rrange.map(
    //         function(r, i){
    //           return (i >= rmin && i <= rmax)
    //         }
    //       )
    //     )
    //   } else{
    //     mapFn = utils.booleanMap(
    //       rrange.map(
    //         function(r, i){
    //           var c;
    //           for(c in csvData){
    //             if (csvData[c][r] == rexp[c]){
    //               return true
    //             }
    //           }
    //           return false
    //         }
    //       )
    //     );
    //   }
    //   return Object.keys(csvData).reduce(
    //     function (d, c){
    //       d[c] = mapFn(csvData[c]);
    //       return d
    //     }, 
    //     {}
    //   )
    // },
    // load: function(rows, cols){
    //   var self;
    //   self = this;
    //   console.log(utils.asArray(cols));

    //   if (arguments.length === 1){
    //     cols = rows;
    //     return self.get(utils.asArray(cols));
    //   }
    //   return self.subsetRows(rows, self.subsetCols(utils.asArray(cols)))
    // },
    // // DOM API methods
    // loadView: function(){
    //   var self, viewParams, rows, cols, format, load;
    //   self = this;
    //   if (!self.view || self.view === 'none'){
    //     return {'error': 'no view set to load'}
    //   }
    //   viewParams = self.view.split(";");
    //   rows = JSON.parse(viewParams[0]);
    //   cols = JSON.parse(viewParams[1]);
    //   format = viewParams[2] || null;
    //   load = self.load(rows, cols); 
    //   switch(format){
    //     case 'row-wise':
    //       self.data = utils.transpose(
    //         cols.reduce(
    //           function(larr, c){
    //           return larr.concat(load[c])
    //           }, 
    //           []
    //         )
    //       ).map(
    //           function(r){
    //             return r.reduce(
    //               function(ro, v, i){
    //                 ro[cols[i]] = v;
    //                 return ro
    //               },
    //               {}
    //             )
    //           }
    //         )
    //     break;
    //     case 'matrix': 
    //        self.data = utils.transpose(
    //         cols.reduce(
    //           function(larr, c){
    //           return larr.concat(load[c])
    //           }, 
    //           []
    //         )
    //       ) 
    //     break;
    //     default:
    //       self.data = load; 
    //   }
    // }

  });

</script>
