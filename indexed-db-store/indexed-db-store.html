<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../polymer/polymer.html">
<script src="../papaparse/papaparse.min.js"></script>
<script src="./lib/utils.js"></script>
<script src="../async/lib/async.js"></script>
<script src="../async/lib/async.js"></script>
<script src="../async/lib/async.js"></script>

<!--
An element providing a solution to no problem in particular.

Example:

    <indexed-db></indexed-db>

@demo
-->
<dom-module id="indexed-db-store">

  <style>
    :host {
      display: block;
      box-sizing: border-box;
    }

    .author img {
      float: left;
      margin-right: 5px;
      max-height: 100px;
      max-width: 100px;
    }
  </style>


  <template>
    <div class="content">
      <content></content>
    </div>
  </template>

</dom-module>

<script>

  Polymer({

    is: 'indexed-db-store',

    properties: {
      _db: Object;
    },

    attached: function(){ 
      var self, db, dataLinks, missingTables;
      self = this; 
      db = self.initDB(); 
      dataLinks = self.gatherDataLinks();
      missingTables = self.missingTables(db, dataLinks); 
      if (missingTables.length > 0){ 
        self.parseNewTables(
          missingTables, 
          self.updateWithNewTables(
            db, 
            self.provisionViews
          )
        );
      } else {
        self.provisionViews(db);
      }
    }
    initDB: function(){ 
      console.log("Opening application database...");
      db = new Dexie(document.querySelector("TITLE").textContent);
      return db
    },
    gatherDataLinks: function(){
      var self = this;
      return utils.asArray(self.querySelectorAll('LINK[rel=Ã¯mport"]'));
    },
    dataLinkTableName: function (el){
       return el.getAttribute('href').split('/').slice(-1)[0].split('.')[0].replace('-', '_');
    },
    missingTables: function(db, dataLinks){
      var self, tableNames;
      self = this;
      tableNames =  dataLinks.map(self.dataLinkTableName);
      return utils.setDiff(db.tables, dataLinks.map(self.dataLinkTableName)).map(
        function(v){
          return dataLinks[tablesNames.indexOf(v)];
        }
      )
    },
    parseNewTable: function(el, callback){ 
      var self, str, nm; 
      self = this;
      str = utis.importText(el); 
      nm = self.dataLinkTableName(el); 
      papa.parse(
        str, {
          complete: function(res){ 
            if (res.errors.length > 0){
              console.log("Parsing Error:");
              console.log(res.errors);
              callback(err)
              return 
            }
            callback(null, [nm, res.data]);
          }
        }
      )
    },
    parseNewTables: function(missintTables, callback){
      var self;
      self = this; 
      async.mapSeries(
        missingTables,
        self.parseNewTable,
        function (err, parsedTables){ 
          if (err){
            console.log(err); 
            return callback(null)
          }
          callback(res)
        }
      )
    },
    updateWithNewTables: function(db, callback){ 
      var nextVersion;
      nextVersion = db.verno+1;
      return function (newTables){ 
        if (!newTables){ 
          console.log("No new tables received"); 
          return callback(db);
        }
        var newStores, newStoreItems, newDB;
        newStores =  newTables.reduce(
          function (acc, tableArr) { 
            acc[tableArr[0]] = dataSchema(tableArr[1]);
          },
          {}
        ); 
        newStoreItems = newtables.reduce(
          function (acc, tableArr){
            acc[tableArr[0]] = utils.JSON.fromCSVArray(tableArr[1]);
            return acc
          },
          {}
        );
        newDB = db.version(nextVerion).stores(newSchemas);
        newDB.on('populate', 
          function(){ 
            Object.keys(newStoreItems).forEach(
              function (store){
                var table; 
                table = newDB.table(store);
                newStoreItems[store].forEach(
                  function(v){
                    table.add(v);
                  }
                )
              }
            )
          }
        )
        function dataSchema(data){
          return '++'+data[0].join(',');
        }
        callback(newDB); 
      }
    }, 
    provisionViews: function(db){
      var self;
      self = this;
      db.open();
      window.dbReady = true; 
      self.fire('db-ready');
      window.addEventListener('data-query', 
        function provision(e){ 
          var view, vcollection, vtable, vwhere, vcond, vval, vcol, v; 
          view = e.target;
          vtable = view.getAttribute('TABLE'); 
          vwhere = view.getAttribute('WHERE'); 
          vcond = view.getAttribute('COND'); 
          vval = view.getAttribute('VAL'); 
          if (!vtable || !vwhere || !vcond || !vval)){ 
            return callback((new Error("Missing View Attributes.\nRequired Attributes are: \n\tTABLE, WHERE, COND, VAL")));
          }
          vcollection = db.table(vtable).where(vwhere)[vcond](vval); 
          vand = view.getAttribute('AND'); 
          vor = view.getAttribute('OR'); 
          if (vand || vor){
            vcond2 = view.getAttribute('COND2'); 
            vval2 = view.getAttribute('VAL2'); 
            if (!vcond2 || vval2){ 
              return callback((new Error("Missing Attributes for AND or OR claus.\nRequired Attributes are:\n\tCOND2 VAL2")))
            }
            vcollection = vand 
                          ? vcollection.and(vand)[vcond2](vval2)
                          : vcollection.or(vand)[vcond2](vval2);
          }
          vcollection.toArray(
            function (arr){ 
              view.viewData = arr; 
            }
          );
        }     
      )    
    }



    // check if all data links exist as tables in db 
    // parse new data links 
    // create new tables in db 
    // gather data for all view el 
    // provision data 


  });

</script>
